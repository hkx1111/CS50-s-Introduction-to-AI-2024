# 第 0 讲 - CS50's 人工智能导论与 Python

对[认证证书、专业证书或学分转换和认证](../../#how-to-take-this-course)感兴趣吗？

## 搜索（Search）

搜索问题是人工智能中的基本问题。在搜索问题中，我们有：

- 一个初始状态
- 一个目标测试函数，用于确定当前状态是否为目标状态
- 一个后继函数，返回从当前状态可能的所有动作
- 一个行动成本函数（有时也称为步长成本函数）

搜索问题的解决方案是一系列动作（行动），这些动作可以让我们从初始状态到达满足目标测试的状态。

### 术语

- **代理（Agent）**：进行搜索的实体
- **状态（State）**：环境的一个配置
- **初始状态（Initial State）**：搜索开始的状态
- **行动（Actions）**：状态的选择/可用的动作
- **转移模型（Transition Model）**：描述在特定状态下执行特定动作后会发生什么的模型
- **状态空间（State Space）**：从初始状态可以到达的所有状态的集合
- **目标测试（Goal Test）**：确定当前状态是否为目标状态
- **路径成本（Path Cost）**：到达某个状态的代价

让我们通过一个迷宫的例子来理解这些概念：

- 初始状态：代理的起始位置
- 行动：上、下、左、右移动
- 转移模型：根据选择的动作移动到新的位置
- 状态空间：迷宫中所有可能的位置
- 目标测试：是否达到终点
- 路径成本：移动的步数

### 搜索类型

**节点（Node）**:是一个数据结构，包含：

- 一个状态
- 其父节点（导致这个节点的动作）
- 到达该节点的成本

#### 深度优先搜索（Depth-First Search，DFS）

- 尽可能深入地探索每条路径
- 使用栈（后进先出，LIFO）
- 不一定找到最短路径
- 内存效率高：O(n)，其中 n 是最长路径的长度
- 可能陷入无限循环
- 也不完整：可能找不到解决方案

#### 广度优先搜索（Breadth-First Search，BFS）

- 探索所有可能的初始动作，然后进一步探索
- 使用队列（先进先出，FIFO）
- 保证找到最短路径
- 内存消耗大：O(b^d)，其中 b 是分支因子，d 是解的深度
- 完整：总能找到解决方案（如果存在）

#### 知情搜索

之前讨论的搜索算法都是"盲目的"，不考虑目标的位置。知情搜索使用启发式函数来估计从当前状态到目标的成本。

**贪婪最佳优先搜索**

- 扩展最接近目标的节点
- 使用启发式函数 h(n)估计从节点 n 到目标的成本
- 不保证找到最优解

**A\* 搜索**

- 扩展"最有希望"的节点
- 使用函数 f(n) = g(n) + h(n)
  - g(n)是到达节点 n 的成本
  - h(n)是从 n 到目标的估计成本
- 如果 h(n)是可接受的（从不高估实际成本），保证找到最优解

#### 对抗搜索

在有对手的情况下（如游戏），我们使用对抗搜索。

**极小极大（Minimax）算法**

- 在双人零和博弈中使用
- 一个玩家试图最大化分数，另一个试图最小化
- 为每个状态分配一个值：
  - 最大值表示最优对"最大化"玩家
  - 最小值表示最优对"最小化"玩家

**Alpha-Beta 剪枝**

- 优化极小极大算法
- 跳过不会影响最终决策的状态
- 通过记录：
  - α：最大化玩家的最佳保证值
  - β：最小化玩家的最佳保证值

### 总结

搜索是人工智能中的基础问题。不同的搜索算法有不同的特点：

- DFS 适用于内存受限的情况
- BFS 保证找到最短路径
- 知情搜索使用额外信息来提高效率
- 对抗搜索处理竞争环境

选择合适的搜索算法取决于具体问题的特点，如：

- 状态空间的大小
- 是否需要最优解
- 时间和内存的限制
- 是否有对抗性
