## 总结下 lecture0 里提到的几种搜索算法

在 CS50’s Introduction to AI with Python 课程的 Lecture 0（Search）中，主要介绍了以下几种搜索算法：

**一、无信息搜索（Uninformed Search）**

无信息搜索算法在搜索过程中不使用任何关于目标节点位置的信息，只基于搜索树结构进行探索。

1. **广度优先搜索（Breadth-First Search, BFS）**

   - 基本思想：逐层扩展节点，先探索所有浅层节点，再逐步深入。
   - 特点：
     - 使用队列（Queue）实现。
     - 能够保证找到最短路径（在每一步代价相等的情况下）。
     - 空间复杂度较高，可能会占用大量内存。
   - 适用场景：当状态空间较浅，且需要找到最短路径时。

2. **深度优先搜索（Depth-First Search, DFS）**

   - 基本思想：沿着一条路径一直向下探索，直到无法继续，再回溯到上一个节点继续探索其他路径。
   - 特点：
     - 使用栈（Stack）或递归实现。
     - 空间复杂度较低，但可能陷入无限深度或次优解。
     - 不一定能找到最短路径。
   - 适用场景：状态空间较大但深度有限时，或者只需找到任意解而非最优解时。

3. **深度受限搜索（Depth-Limited Search）**

   - 基本思想：是 DFS 的一种变体，限制了搜索的最大深度。
   - 特点：
     - 可避免 DFS 中的无限深度问题。
     - 若限制深度过浅，则可能无法找到解；若过深，则可能退化为普通 DFS。
   - 适用场景：当对问题的解所在的最大深度有一定了解时使用。

4. **迭代加深搜索（Iterative Deepening Search, IDS）**

   - 基本思想：结合 BFS 和 DFS 的优势，从浅到深逐渐增加搜索深度限制，每次都进行一次深度受限搜索。
   - 特点：
     - 能够保证找到最短路径（在每一步代价相等的情况下）。
     - 空间复杂度与 DFS 相同，时间复杂度略高于 BFS，但实际应用中表现良好。
   - 适用场景：当状态空间较大且未知最优解的深度时。

**二、有信息搜索（Informed Search）**

有信息搜索算法利用启发式函数（Heuristic Function）评估节点到目标节点的距离，从而更高效地进行搜索。

1. **贪婪最佳优先搜索（Greedy Best-First Search）**

   - 基本思想：每次选择启发式函数值最低的节点进行扩展，即选择看起来离目标最近的节点。
   - 特点：
     - 搜索速度快，但不一定能找到最优解。
     - 易陷入局部最优解。
   - 适用场景：需要快速找到一个可行解，而不要求严格最优时。

2. **A\* 搜索算法**

   - 基本思想：结合了贪婪最佳优先算法和广度优先算法的优点，通过函数 来评估节点。其中：
     - ：从起点到当前节点 的实际代价。
     - ：从当前节点 到目标节点的启发式估计代价。
   - 特点：
     - 在启发式函数满足一致性条件（consistent heuristic）或可接受条件（admissible heuristic）的情况下，保证找到最优解。
     - 广泛应用于路径规划、游戏 AI 等领域。
   - 适用场景：需要保证找到最优解并且拥有合适启发式函数时。

以上便是 Lecture 0 中提到的重要搜索算法及其主要特点和适用场景。
