# 了解

这个项目中有两个 Python 文件：crossword.py 和 generate.py。第一个文件已经完全为您编写，第二个文件有一些需要您实现的功能。

首先，让我们看看 crossword.py。此文件定义了两个类，Variable（用于表示填字游戏中的变量）和 Crossword（用于表示拼图本身）。

请注意，要创建 Variable，我们必须指定四个值：它的行 i，它的列 j，它的方向（常量 Variable.ACROSS 或常量 Variable.DOWN）和它的长度。

Crossword 类需要两个值才能创建一个新的填字游戏：一个 structure_file，用于定义拼图的结构（_ 用于表示空白单元格，任何其他字符表示不会填充的单元格）和一个 words_file，用于定义要用于拼图词汇表的单词列表（每行一个单词）。在项目的 data 目录中可以找到这两种文件的三个示例，欢迎您自己创建它们。

特别要注意的是，对于任何填字对象 crossword，我们存储以下值：

*   `crossword.height` 是一个表示填字游戏高度的整数。
*   `crossword.width` 是一个表示填字游戏宽度的整数。
*   `crossword.structure` 是一个表示拼图结构的二维列表。对于任何有效的行 i 和列 j，如果单元格是空白的（必须在那里填充一个字符），则 `crossword.structure[i][j]` 将为 True，否则（没有要填充的字符），将为 False。
*   `crossword.words` 是在构造填字游戏时要从中提取的所有单词的集合。
*   `crossword.variables` 是拼图中所有变量的集合（每个变量都是一个 Variable 对象）。
*   `crossword.overlaps` 是一个字典，将一对变量映射到它们的重叠。对于任何两个不同的变量 v1 和 v2，如果这两个变量没有重叠，则 `crossword.overlaps[v1, v2]` 将为 None，如果变量确实重叠，则将是一个整数对 (i, j)。对 (i, j) 应被解释为 v1 的值的第 i 个字符必须与 v2 的值的第 j 个字符相同。

Crossword 对象还支持一个方法 neighbors，该方法返回与给定变量重叠的所有变量。也就是说，`crossword.neighbors(v1)` 将返回一个与变量 v1 相邻的所有变量的集合。

接下来，看一下 generate.py。在这里，我们定义了一个类 CrosswordCreator，我们将使用它来解决填字游戏。创建 CrosswordCreator 对象时，它会获得一个属性 crossword，该属性应为 Crossword 对象（因此具有上面描述的所有属性）。每个 CrosswordCreator 对象还具有一个属性 domains：一个字典，该字典将变量映射到变量可能采用值的可能单词的集合。最初，这组单词是我们词汇表中的所有单词，但我们很快将编写函数来限制这些域。

我们还为您定义了一些函数，以帮助测试您的代码：print 将在给定分配的情况下将您的填字游戏的表示形式打印到终端（每个分配，在此函数和别处，都是一个将变量映射到其相应单词的字典）。同时，save 将生成与给定分配相对应的图像文件（如果您尚未安装，则需要 `pip3 install Pillow` 才能使用此函数）。letter\_grid 是 print 和 save 都使用的一个辅助函数，它为给定分配生成一个二维列表，其中包含所有字符及其适当位置：您可能不需要自己调用此函数，但是如果您愿意，可以调用。

最后，请注意 `solve` 函数。此函数执行三件事：首先，它调用 `enforce_node_consistency` 以在填字游戏上强制执行节点一致性，确保变量域中的每个值都满足一元约束。接下来，该函数调用 `ac3` 以强制执行弧一致性，确保满足二元约束。最后，该函数在最初为空的分配（空字典 `dict()`）上调用 `backtrack`，以尝试计算问题的解决方案。

但是，函数 `enforce_node_consistency`、`ac3` 和 `backtrack` 尚未实现（以及其他函数）。这就是你加入的地方！

## 规范

完成 generate.py 中 `enforce_node_consistency`、`revise`、`ac3`、`assignment_complete`、`consistent`、`order_domain_values` 和 `backtrack` 的实现，以便您的 AI 能够生成完整的填字游戏（如果可能）。

*   **`enforce_node_consistency` 函数**应该更新 `self.domains`，以便每个变量都具有节点一致性。

    回想一下，当对于每个变量，其域中的每个值都与其变量的一元约束一致时，就实现了节点一致性。在填字游戏的情况下，这意味着确保变量域中的每个值都具有与变量长度相同数量的字母。

    要从变量 v 的域中删除一个值 x，由于 `self.domains` 是一个将变量映射到值集合的字典，您可以调用 `self.domains[v].remove(x)`。

    此函数不需要返回值。

*   **`revise` 函数**应该使变量 x 与变量 y 弧一致。

    x 和 y 都将是表示拼图中变量的 Variable 对象。

    回想一下，当 x 的域中的每个值都有 y 的域中没有冲突的可能值时，x 与 y 弧一致。（在填字游戏的上下文中，冲突是指两个变量对应该采用哪个字符值存在分歧的方格。）

    要使 x 与 y 弧一致，您需要从 x 的域中删除任何没有 y 的域中对应可能值的值。

    回想一下，您可以访问 `self.crossword.overlaps` 来获取两个变量之间的重叠（如果有）。

    应该保留 y 的域。

    如果对 x 的域进行了修订，则该函数应返回 True；如果未进行任何修订，则应返回 False。

*   **`ac3` 函数**应该使用 AC3 算法在问题上强制执行弧一致性。回想一下，当每个变量的域中的所有值都满足该变量的二元约束时，就实现了弧一致性。

    回想一下，AC3 算法维护一个要处理的弧队列。此函数采用一个名为 `arcs` 的可选参数，该参数表示要处理的初始弧列表。如果 `arcs` 为 None，则您的函数应从问题中的所有弧的初始队列开始。否则，您的算法应该从仅在 `arcs` 列表中（其中每条弧是变量 x 和不同变量 y 的元组 (x, y)）的弧的初始队列开始。

    回想一下，要实现 AC3，您需要一次修订队列中的每条弧。但是，每次您对域进行更改时，您可能需要向队列中添加额外的弧，以确保其他弧保持一致。

    您可能会发现，在您的 `ac3` 实现中调用 `revise` 函数会很有帮助。

    如果在强制执行弧一致性的过程中，您从域中删除了所有剩余的值，则返回 False（这意味着无法解决该问题，因为该变量不再有任何可能的值）。否则，返回 True。

    您无需担心在此函数中强制执行单词唯一性（您将在 `consistent` 函数中实现该检查。）

*   **`assignment_complete` 函数**应该（顾名思义）检查给定的分配是否完整。

    分配是一个字典，其中键是 Variable 对象，值是表示这些变量将采用的单词的字符串。

    如果每个填字游戏变量都分配了一个值（无论该值是什么），则分配是完整的。

    如果分配完成，则该函数应返回 True，否则返回 False。

*   **`consistent` 函数**应该检查给定的分配是否一致。

    分配是一个字典，其中键是 Variable 对象，值是表示这些变量将采用的单词的字符串。请注意，分配可能不完整：并非所有变量都必须存在于分配中。

    如果分配满足问题的所有约束，则分配是一致的：也就是说，所有值都是不同的，每个值的长度都正确，并且相邻的变量之间没有冲突。

    如果分配一致，则该函数应返回 True，否则返回 False。

*   **`order_domain_values` 函数**应该根据最少约束值启发式方法返回 var 的域中的所有值的列表。

    `var` 将是一个 Variable 对象，表示拼图中的一个变量。

    回想一下，最少约束值启发式方法计算为为相邻的未分配变量排除的值的数量。也就是说，如果将 `var` 分配给特定值会导致为相邻变量排除 n 个可能的选择，则应该按 n 的升序对结果进行排序。

    请注意，分配中存在的任何变量已经具有一个值，因此在计算为相邻的未分配变量排除的值的数量时，不应计算在内。

    对于排除相邻变量相同数量的可能选择的域值，任何排序都是可以接受的。

    回想一下，您可以访问 `self.crossword.overlaps` 来获取两个变量之间的重叠（如果有）。

    通过按任意顺序返回值列表来首先实现此函数可能会有所帮助（这仍然应该生成正确的填字游戏）。一旦您的算法运行正常，您就可以返回并确保按正确的顺序返回这些值。

    根据特定的键对列表进行排序可能会有所帮助：Python 包含一些有用的函数来实现此目的。

*   **`select_unassigned_variable` 函数**应该根据最小剩余值启发式方法，然后是度数启发式方法，返回填字游戏中尚未由分配分配的单个变量。

    分配是一个字典，其中键是 Variable 对象，值是表示这些变量将采用的单词的字符串。您可以假设分配不会完成：并非所有变量都将存在于分配中。

    您的函数应返回一个 Variable 对象。您应该返回其域中剩余值最少的变量。如果变量之间存在平局，您应该在那些具有最大度数（具有最多邻居）的变量中进行选择。如果在这两种情况下都存在平局，您可以任意选择平局变量。

    通过首先返回任何任意的未分配变量来首先实现此函数可能会有所帮助（这仍然应该生成正确的填字游戏）。一旦您的算法运行正常，您就可以返回并确保您根据启发式方法返回一个变量。

    根据特定的键对列表进行排序可能会有所帮助：Python 包含一些有用的函数来实现此目的。

*   **`backtrack` 函数**应该接受部分分配 `assignment` 作为输入，并使用回溯搜索，如果可能，返回一个完全令人满意的变量到值的分配。

    分配是一个字典，其中键是 Variable 对象，值是表示这些变量将采用的单词的字符串。输入的分配可能不完整（并非所有变量都必须具有值）。

    如果可能生成令人满意的填字游戏，则您的函数应返回完整的分配：一个字典，其中每个变量都是一个键，而值是该变量应该采用的单词。如果不存在令人满意的分配，则该函数应返回 None。

    如果愿意，您可能会发现，如果将搜索与推理交错进行（例如，每次进行新分配时都保持弧一致性），您的算法会更有效。这不是必需的，但允许您这样做，只要您的函数仍然产生正确的结果。（出于这个原因，`ac3` 函数允许一个 `arcs` 参数，以防您想从不同的弧队列开始。）

    您不应该修改 generate.py 中的任何其他内容，除了规范要求您实现的函数，尽管您可以编写其他函数和/或导入其他 Python 标准库模块。如果您熟悉 numpy 或 pandas，也可以导入它们，但是您不应该使用任何其他第三方 Python 模块。您不应该修改 crossword.py 中的任何内容。

## 提示

*   对于 `order_domain_values` 和 `select_unassigned_variable`，先实现它们，不要担心启发式方法，然后再添加启发式方法可能会有所帮助。您的算法仍然可以工作：它可能只是在找到解决方案之前探索比它需要的更多的分配。
*   要运行您的程序，您可以运行类似 `python generate.py data/structure1.txt data/words1.txt` 的命令，指定一个结构文件和一个单词文件。如果一个分配是可能的，您应该会看到生成的分配被打印出来。您还可以添加一个额外的命令行参数来指定一个图像文件，例如运行 `python generate.py data/structure1.txt data/words1.txt output.png`，以生成生成的填字游戏的图像表示。
*   `Crossword` 类有一个 `neighbors` 函数，您可以使用它来访问特定变量的所有邻居（即重叠变量）。随时使用它来确定特定变量的邻居！
